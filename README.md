# what I did

### main 10.12.2024

1. 修改了文件结构，现在的文件结构如下

> app/  
> ├── src/  
> │   ├── main/  
> │   │   ├── java/  
> │   │   │   └── com/  
> │   │   │       └── example/  
> │   │   │           ├── controller/  
> │   │   │           │   └── MyController.java  
> │   │   │           ├── model/  
> │   │   │           │   └── MyModel.java  
> │   │   │           |── MainApp.java  
> 
> |   |    |            |------ view/
> │   │   ├── resources/  图片(images/)也在这
> │   │   │   ├── fxml/  
> │   │   │   │   └── myview.fxml  
> │   │   │   └── css/  
> │   │   │       └── styles.css  
> │   │   └── ...  
> │   └── test/  
> └── pom.xml 

2. 规范化了文件的名字
- java文件全部采用单词首字母大写命名

> OptionController.java

- fxml文件全部采用小写命名

> setting.fxml
> 
> 并且内部引用图片文件只需要./../images

3. 选定Start.java作为入口文件，其他作为辅助写代码的文件（仅仅参考作用，在最终的项目中需要被删除）

4. 删除了start.fml中不必要的节点

5. css文件放在了/resources/fxml下

6. 将HomeController.java内的一个FXML加载函数的fxml文件从"sample"改成了"option"，因为home.fxml文件中，是Option按钮的回调函数

7. 修改了所有fxml文件的引用其他资源文件的方式，主要采用“@”引用，同时折叠了所有标签，更方便调试

8. 在option.fxml通过按下按钮选择角色，然后把选择角色的信息保存在主类中

> ![](./readme_images\2024-12-10-05-56-07-image.png)
> 
> 这个菜单栏是不是没啥用？这个界面的化只要完成角色的选择就行了。

9. 我发现你写代码的一些问题，文件名，函数名，变量名大部分都是乱命名的，文件的存放也没有规律，这种让新接手项目的人阅读难度提升极大。

> 比如函数名使用了这种命名方法：
> 
> Switch_toHome
> 
> 一般第一个字母小写，然后后面用驼峰或者用全小写加下划线，例如：
> 
> switch_to_home
> 
> switchToHome
> 
> switch2home
> 
> switch2Home
> 
> to经常在命名中用2表示
> 
> .
> 
> 而且资源文件大小写混用，甚至拓展名也有“PNG”的，拓展名一般默认是小写的
> 
> 甚至有下划线，大小写全部混在一起命名的文件:
> 
> Intro_background.jpg

重构了大部分内容，完成了部分gui逻辑。

### feature1 v2 11.12.2024

1. 重构了所有代码

2. HomePageContontroller.java有什么用？目前写代码没有用到

3. 创建了object/文件夹，用来存放一些数据结构，例如user选择的character，完成逻辑的过程中还有可能会有得分，游戏状态之类的。

4. 添加了6种设计模式

> Decorator
> 
> Factory
> 
> ObservedSubject
> 
> Observer
> 
> Singleton
> 
> Strategy

> 然后我的理解是需要在编写游戏逻辑的时候用到这些设计模式并且标明哪个类用了这个设计模式对吗？
> 
> 例如 object/GameState.java这个类使用了Singleton的设计模式，就在类的前面注释使用了这个设计模式，是这样吗？

5. 尝试写了一点对函数的javadoc，符合你们要求的格式吗？如果符合后面就采用这种方式进行javadoc标注

> ![](.\readme_images\Snipaste_2024-12-11_04-05-18.png)

### feature2 v3 11.12.2024

1. 添加函数Start.initContent用来给Start.appRoot初始化和Start.creatEntity函数

2. 修改了一些Start成员的访问类型(private)

3. 把Start改成了单例模式，并且在init中初始化instance

4. 将主窗口变成unresizable，固定为1280x720

5. 添加了按下option->start之后的进入游戏的主逻辑，可以根据按下start之前玩家选择进入游戏界面（character, map）。

6. 定义游戏的积分规则

> - 这是原版积分规则
> 
> > ![](.\readme_images\Snipaste_2024-12-11_19-17-45.png)
> > 
> > 这个得分规则有点奇怪，通关时间和得分正相关
> 
> - 我定义了新的积分规则，时间最长为300秒，如果超过，判为game over
> 
> > (300-T) +1000*(n/N)
> > 
> > 其中T代表通过时间，n表示获取的物资，N表示总物资，这些数据可能和地图有关，也可能是随机生成的数据。
> > 
> > 并生成了ScoreCalculator.calculateScore函数

7. 删除（注释）了home.fxml中的menu bar（至少目前没用）

8. 更改了character.fxml角色下面的按钮对应的名称问题。

9. 更改了进入游戏之后使用的背景图片（由黑色背景改成map对应的图片）

10. 添加了计时逻辑和计时label，并且添加了一个quit game按钮，用来直接退到home.fxml

11. 更改了部分碰撞逻辑

12. 修改了object.Character  (Decorator)

13. 添加了object.Map  (Decorator)

14. 添加了game_over.fxml，游戏因某种原因结束的时候展示

15. 修改GameState为Factory pattern

16. 背景素材有点少，在测试一个图片的过程中出现了明显的糊了的效果。

> ![](./readme_images\Snipaste_2024-12-11_22-06-07.png)

17. 修改了角色的身高，由于每个角色图片的w:h都不一样，如果让Amy这个角色的高度为60，那Carl这个角色的高度会超过60，会导致有些地方过不去，所以，让角色的w:h大致为 25:50，部分男角色身高可能为51，52左右

18. 添加了file/文件夹，用来存储一些文本文件

> 例如 scores.json

19. 添加了object/Score.java，用来序列化和反序列化，方便存储和读取数据。

20. 添加了test/测试文件夹，并且添加了一个测试

### feature3 v4 12.12.2024

1. 添加了scores.json文件以及数据内容的错误处理系统

2. 在playerController中添加了镜像逻辑，当角色向左走动的时候，图片会朝向左边，反之亦然。

3. 添加了gameState从TimeLabel获取耗时并保存在gameState里面，将会在“score”页面处理得分。

4. 创建了几个文件用来分类不同素材

5. 缺失素材或素材不适合

> - 缺少素材
> 
> > 饼干
> 
> - 素材不适合
> 
> > enemy的火龙，需要在天上飞应该要有翅膀
> > 
> > enemy的木乃伊，太呆了
> > 
> > platform由于是一块一块的60x60像素构成的方块，所以需要的不是很大一片的图，而是一小块一小块的，上面可以有雪覆盖。可以多找几个这样的小块单元，实在不行可以从大图里面ps扣下来一块

ps. 今天没多少时间，只写了一些代码。

### feature4 v5 13.12.2024

1. 创建了utils/InitContent和utils/InitContentAdapter用来初始化地图，采用Adapter pattern

2. 创建了object/EntityCreator，object/Entity和object/Player用来生成初始化角色的数据，采用factory pattern

3. 创建了PlatformBlock用来初始化platform平台的块

4. 定义level1中出现的实体
- 平台方块

- 大冰块

- 小冰块

- 冰面方块（加速，在其上面加速度更大）

- 雪面方块（减速，在其上面加速度更小）

- 纯净水

- 罐头

- 饼干

> 定义它们在地图（字符矩阵）中的值从上到下为
> 
> 平台方块  1
> 
> 大冰块      2
> 
> 小冰块      3
> 
> 冰面方块（加速，在其上面加速度更大） 4
> 
> 雪面方块（减速，在其上面加速度更小） 5
> 
> 纯净水      6
> 
> 罐头          7
> 
> 饼干          8
> 
> 雪屋          9

> 定义它们的模型尺寸为
> 
> 1   60x60
> 
> 2   120x120
> 
> 3   60x60
> 
> 4   60x60
> 
> 5   60x60
> 
> 6   20x20
> 
> 7   20x20
> 
> 8   20x20
> 
> 9   120x120

由于player固定出生在左边，所以不需要通过地图定义

另外，player的size是

> 25x50

5-1. level1地图设计

> 用compass这个CAD软件设计
> 
> ![](.\readme_images\Snipaste_2024-12-14_03-52-46.png)
> 
> 可得出其levelData为
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00006000 00111000 00000000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00001000 01111100 00000000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000
> 
> 00000000 00000000 00006000 00000000 00000001 11000000 00000000 00000000 000
> 
> 00006000 00000000 00003000 00000000 00000011 11100070 00000007 00000000 000
> 
> 00001110 00000000 00003000 00000000 00000000 00000030 00000011 10000000 000
> 
> 00000000 00000000 00033000 00000000 00000000 00000030 00000000 00000000 000
> 
> 00000000 00000300 00111000 00000002 00000000 00003333 00000000 00000000 000
> 
> 00000000 00000330 00000000 00000000 00000000 00003333 00000000 00300000 000
> 
> 00000002 00003333 00000000 20207002 02000000 00033333 00000000 00300900 000
> 
> 11110001 11111111 11444000 11111001 11111555 00011111 00000555 11111111 111
> 
> 0-7      8-15     16-23    24-31    32-39    40-47    48-55    56-63    64-66

5-2.  level2地图设计

> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000
> 
> 11111100 00000007 00000000 00001111 00000800 00000000 00000000 00280000 000
> 
> 00000011 00000111 05000000 00000000 01111100 00000000 00000000 11110000 000
> 
> 00000000 00000000 01110000 00000000 00000000 00000000 00003000 00000000 000
> 
> 07000110 00000000 00009000 00003070 00000090 00000000 00111110 00004000 000
> 
> 01111111 00400000 00000000 00001111 00000000 00000000 00000000 00070000 000
> 
> 00001111 00000000 00000000 00000000 00000000 00000000 00000000 00110000 000
> 
> 06000000 00000020 00000000 00000000 00000000 00000300 00011111 00000000 000
> 
> 01111110 00011111 00500002 00000000 00005800 00000111 00000000 00000000 000
> 
> 00000000 00000000 11111111 00000060 00011111 11100000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00111111 00000000 00000000 00000007 23300a00 000
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00011111 11111111 111
> 
> 0-7      8-15     16-23    24-31    32-39    40-47    48-55    56-63    64-66
> =======

6. 定义不同level的platform的tag

> - glacier_platform_block1.png  tag = 1
> 
> ![](./src\main\resources\images\platform\glacier_platform_block3.png)

7. 由于没有合适的冰块素材，决定将下面这个冰块通过变成120x120像素以表示大冰块，并且60x60表示小冰块

> ![](./src\main\resources\images\obstacle\glacier_ice_block.png)

8. 添加了game_over.fxml和controller，当游戏失败的时候展示

9. 定义冰面方块，使用这个方块作为冰面方块，当玩家在上面行走的时候，加速度（按d）会增大，减速度（不按）减小，由于没有惯性系统，没有加速度概念，所以定义在该方块上移动时比在普通方块上移动单位时间长度上时间的比值为1.5 : 1

> ![](.\src\main\resources\images\feature\glacier_ice_block.jpg)

10. 由于在两个地图中都有一些feature blocks，例如在雪地地图上，有冰块和雪块，在沙漠地图上有移动的飞毯。

> 定义featuresBlocks用来存储这些特定方块，并且在每个时间刻区别于platform来进行一些feature blocks的判定（而platform则只用来给playerController做碰撞箱判定）

11. ui退出和game_over的restart不会删除之前的timer，导致了计时bug

12. 实现了在冰块上加速和在雪块上减速的逻辑

13. 实现了在地图上放置supply

14. 实现了拾取supply的逻辑

15. 素材图问题
    
    > 沙漠的终点绿洲不符合，太大了，需要一个单体就够，就像雪屋那样的最好。

### feature5 v6 14.12.2024

1. 添加了背景音乐，并且选择了一个合适的音量大小

2. 修改了timer的位置

3. 修复了游戏内计时器的bug (feature4 11)

4. 由于雪屋图片的比例是5:2，所以修改雪地的雪屋模型尺寸为

> 250x100

5. 添加了雪屋，并完成游戏胜利判定，并给出得分和保存历史最佳成绩。

6. 定义level2中出现的实体
- 平台方块

- 石头

- 仙人掌

- 火龙

- 木乃伊

- 纯净水

- 罐头

- 饼干

- 魔毯

- 绿洲

> 定义它们在地图（字符矩阵）中的值从上到下为
> 
> 平台方块 1
> 
> 石头 2
> 
> 仙人掌 3
> 
> 火龙 4
> 
> 木乃伊 5
> 
> 纯净水 6
> 
> 罐头 7
> 
> 饼干 8
> 
> 魔毯 9
> 
> 雪屋 10
> 
> 定义它们的模型尺寸为：

7.修复了timeLabel的提取时间的逻辑bug

### feature6 b7 14.12.2024

1.接feature5 6 定义它们的模型尺寸为：

> 1 60x60
> 
> 2 60x60
> 
> 3 60x60
> 
> 4 60x60
> 
> 5 60x50
> 
> 6 20x20
> 
> 7 20x20
> 
> 8 20x20
> 
> 9 200x60
> 
> a 120x100
> ps.由于0-9以及被用光，所以使用'a'代表oasis（16进制）

2. 给出level2地图最终设计

> ![](F:\MyProjects\receive\java_design_mode\code\PlatformerPlain_main\readme_images\Snipaste_2024-12-15_02-49-22.png)
> 
> 字符矩阵为：
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000
> 
> 11111100 00000007 00000000 00001111 00000800 00000000 00000000 00280000 000
> 
> 00000011 00000111 05000000 00000000 01111100 00000000 00000000 11110000 000
> 
> 00000000 00000000 01110000 00000000 00000000 00000000 00003000 00000000 000
> 
> 07000110 00000000 00009000 00003070 00000090 00000000 00111110 00004000 000
> 
> 01111111 00400000 00000000 00001111 00000000 00000000 00000000 00070000 000
> 
> 00001111 00000000 00000000 00000000 00000000 00000000 00000000 00110000 000
> 
> 06000000 00000020 00000000 00000000 00000000 00000300 00011111 00000000 000
> 
> 01111110 00011111 00500002 00000000 00005800 00000111 00000000 00000000 000
> 
> 00000000 00000000 11111111 00000060 00011111 11100000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00111111 00000000 00000000 00000007 23300a00 000
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00011111 11111111 111

3. 定义platform block贴图，综合时间考虑选择全部统一的各向同性的下面这张贴图

> ![](./src\main\resources\images\platform\desert_platform_block2.png)

4. 成功创建了platform block实体

5. 定义cactus实体，采用下面的贴图

> <img title="" src=".\src\main\resources\images\obstacle\desert_cactus.jpg" alt="" width="210">

6. 定义stone实体，采用下面的贴图

> ![](.\src\main\resources\images\obstacle\desert_stone.jpg)

7. 由于原图是jpg格式不带透明度通道，因此通过ps抠图获得png文件，并实现了把这两个实体放入地图

8. 火龙采用素材，由于原来的格式是.git，通过ps获得第一帧的png文件

> ![](.\src\main\resources\images\enemy\desert_firedragon.png)

9. 关于Moveable的设计，moveable采用策略设计模式，所有enemy继承自Entity，并且Entity有成员为moveable，如果moveable值为LineMove，则会调用它的move函数会沿着一条线移动，如果moveable为NoMove，则调用move函数不移动，一次做到算法的区分。

10. 关于enemy相关类的设计

> 1. 抽象类 MovableNode
> 
> 2. 抽象类 EnemyNode 继承 1
> 
> 3. FireDragonNode 继承 2
> 
> 4. MummyNode 继承 2
> 
> MovableNode 拥有成员 range和movable和node
> 
> 当movable是LineMove的时候，在每个时间刻，就会按照range的范围去translate node的位置，一般是横向translate。
> 
> 当movable是NoMove的时候，留空。

11. 实现了enemy的移动，在每一个时间刻都会运行一步，火龙和木乃伊的运动速度由Value.FIRE_DRAGON_MOVE_VELOCITY和Value.MUMMY_MOVE_VELOCITY给出。

12. 当enemy向右移动到range的终点的时候，会镜像照片同时向左移动，反之亦然。

13. 移除了enemy的碰撞箱逻辑

14. 添加了玩家碰到enemy就会game_over的逻辑

15. 使用ps修改了oasis的贴图，使得其更加平整。

16. 关于magic carpet相关类的设计

> 1. 抽象类 MovableNode
> 
> 2. 抽象类 MovableObject 继承1
> 
> 3. FlyingCarpet 继承2

17. 添加flying_carpet

18. 由于flying_carpet不需要在运动到边界的时候turn around，所以给LineMove对象添加了一个Boolean turnAround，用来表示是否需要在到达边界的时候转向。

19. 在地图文件中定义不同的movable对象的move range，并且对于所有的Movable对象，它们会依次从自左向右自上而下的依次读取

> `public static final List<int[]> LevelMovableObjectRanges = new ArrayList<>();`

中的对象，并将它们用于对Movable对象的range的初始化。为此，创建一个迭代器，调用next方法返回一个int[]对象。

> class IntArrayIterator

20. 关卡2设计上有一点问题，稍微修改了一下

> 字符矩阵为：
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000
> 
> 11111100 00000007 00000000 00001111 00000800 00000000 00000000 00280000 000
> 
> 00000011 00001111 05000000 00000000 01111100 00000000 00000000 11110000 000
> 
> 00000000 00000000 01110000 00000000 00000000 00000000 00003000 00000000 000
> 
> 07000110 00000000 00009000 00003070 00000090 00000000 00111110 00004000 000
> 
> 01111111 00400000 00000000 00001111 00000000 00000000 00000000 00070000 000
> 
> 00001111 00000000 00000000 00000000 00000000 00000000 00000000 00110000 000
> 
> 06000000 00000020 00000000 00000000 00000000 00000300 00011111 00000000 000
> 
> 01111110 00011111 00500002 00000000 00005800 00000111 00000000 00000000 000
> 
> 00000000 00000000 11111111 00000060 00011111 11100000 00000000 00000000 000
> 
> 00000000 00000000 00000000 00111111 00000000 00000000 00000007 23300a00 000
> 
> 00000000 00000000 00000000 00000000 00000000 00000000 00011111 11111111 111

21. 关卡2设计完成。
